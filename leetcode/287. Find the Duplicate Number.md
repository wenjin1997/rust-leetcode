# 287. Find the Duplicate Number

## 官方解答

参考[官方解答](https://leetcode.com/problems/find-the-duplicate-number/solution/)，给出了7种方法。

| 方法                                        | 是否需要修改原数组         | 时间复杂度     | 空间复杂度          |
| ------------------------------------------- | -------------------------- | -------------- | ------------------- |
| Sort                                        | 是                         | *O*(*n*log*n*) | *O*(log*n*) or O(n) |
| Set                                         | 否                         | *O*(*n*)       | *O*(*n*)            |
| Negative Marking                            | 是，不过最终可以恢复原数组 | *O*(*n*)       | O(1)                |
| Array as HashMap (Recursion)                |                            |                |                     |
| Array as HashMap (Iterative)                |                            |                |                     |
| Binary Search                               |                            |                |                     |
| Sum of Set Bits                             |                            |                |                     |
| Floyd's Tortoise and Hare (Cycle Detection) | 否                         | *O*(*n*)       | *O*(1)              |



## Set

利用 HashSet 不能添加重复的元素

```rust
use std::collections::HashSet;
impl Solution {
    pub fn find_duplicate(nums: Vec<i32>) -> i32 {
        // 哈希表 hashset
        let mut set: HashSet<i32> = HashSet::new();
        for num in nums {
            if (!set.insert(num)) {
                return num;
            }
            set.insert(num);
        }
        -1
    }
}
```

时间复杂度：O(n)

空间复杂度：O(n)

## Negative marking

```rust
impl Solution {
    pub fn find_duplicate(nums: Vec<i32>) -> i32 {
        // Negative marking
      	// 为了能够修改 nums, 这里克隆了一份
        let mut new_nums = nums.clone();
         
        let mut duplicate = -1;
        for i in 0..new_nums.len() {
            let cur = new_nums[i].abs() as usize;
            if (new_nums[cur] < 0) {
                duplicate = cur as i32;
                break;
            }
            new_nums[cur] = -1 * new_nums[cur];
        }
      
        duplicate
    }
}
```

## Floyd's Tortoise and Hare

```rust
impl Solution {
    pub fn find_duplicate(nums: Vec<i32>) -> i32 {
        // Floyd's Tortoise and Hare

        let (mut tortoise, mut hare) = (&nums[0], &nums[0]);
        loop {
            tortoise = &nums[*tortoise as usize];
            hare = &nums[nums[*hare as usize] as usize];
            if (tortoise == hare) {
                break;
            }
        }

        // 找到环入口点
        // 现将乌龟放到原点
        tortoise = &nums[0];
        while (tortoise != hare) {
            tortoise = &nums[*tortoise as usize];
            hare = &nums[*hare as usize];
        }

        *hare
    }
}
```

或者

```rust
impl Solution {
    pub fn find_duplicate(nums: Vec<i32>) -> i32 {
        // Floyd's Tortoise and Hare

        let (mut tortoise, mut hare) = (nums[0], nums[0]);
        loop {
            tortoise = nums[tortoise as usize];
            hare = nums[nums[hare as usize] as usize];
            if (tortoise == hare) {
                break;
            }
        }

        // 找到环入口点
        // 现将乌龟放到原点
        tortoise = nums[0];
        while (tortoise != hare) {
            tortoise = nums[tortoise as usize];
            hare = nums[hare as usize];
        }

        hare
    }
}
```

这种方法没有借用，而是直接获得所有权，由于 i32 实现了 Copy trait，因此会直接复制，但是实际测试运行时间会比上面的方法长一些。